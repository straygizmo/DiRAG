@using DiRAG.Services
@using DiRAG.Forms
@using Microsoft.JSInterop
@inject IChatService ChatService
@inject MainForm MainForm
@inject IJSRuntime JSRuntime
@inject ILocalizationService Localization
@implements IDisposable

<div class="container-fluid d-flex flex-column vh-100 p-3">
    <div class="mb-3">
        <div class="d-flex justify-content-between align-items-center">
            <div class="text-muted small">
                <span class="me-3">@Localization.GetString("Provider"): <strong>@apiProvider</strong></span>
                <span>@Localization.GetString("Model"): <strong>@modelName</strong></span>
            </div>
            <div>
                <button class="btn btn-sm btn-outline-secondary" @onclick="ShowSelectedDirectories">@Localization.GetString("SelectedDirectories")</button>
                <button class="btn btn-sm btn-outline-secondary ms-2" @onclick="ShowContextDialog">@Localization.GetString("Context")</button>
                <button class="btn btn-sm btn-outline-primary ms-2" @onclick="ClearChat">@Localization.GetString("NewChat")</button>
            </div>
        </div>
        <div class="d-flex align-items-center mt-2">
            <label class="text-muted small me-2">@Localization.GetString("FontSize"):</label>
            <input type="range" class="form-range flex-grow-1" style="max-width: 200px;"
                   min="10" max="32" step="1" value="@fontSize"
                   @oninput="OnFontSizeChanged" />
            <span class="text-muted small ms-2">@fontSize px</span>
        </div>
    </div>
    <div id="chatContainer" class="border rounded p-3 mb-3 flex-grow-1" style="overflow-y: auto; font-size: @(fontSize)px;">
        @foreach (var message in chatHistory)
        {
            <div class="@(message.IsUser ? "text-end" : "text-start") mb-2">
                <span class="badge @GetMessageCssClass(message) p-2 text-wrap chat-message"
                      style="max-width: 80%; display: inline-block; text-align: left; @GetMessageStyle(message)">
                    @if (message.IsUser && message.Type == MessageType.Normal)
                    {
                        @message.Text
                    }
                    else
                    {
                        @((MarkupString)message.Text.Replace("\n", "<br>"))
                    }
                </span>
            </div>
        }
        @if (isWaitingForResponse)
        {
            <div class="text-start mb-2">
                <span class="badge bg-secondary p-2">
                    <span class="dots-animation">
                        <span>.</span><span>.</span><span>.</span>
                    </span>
                </span>
            </div>
        }
    </div>
    <div class="input-group">
        <input type="text" class="form-control" placeholder="@Localization.GetString("EnterMessage")"
               @bind="currentMessage" @bind:event="oninput" @onkeypress="@(async e => { if (e.Key == "Enter") await SendMessageAsync(); })" />
        <button class="btn btn-primary" @onclick="SendMessageAsync">&#x2197;</button>
    </div>
</div>

<DiRAG.Pages.Components.ConfirmDialog @ref="confirmDialog" OnClose="HandleConfirmDialogResult" />

@code {
    private List<ChatMessage> chatHistory = new List<ChatMessage>();
    private string currentMessage = string.Empty;
    private bool isWaitingForResponse = false;
    private int fontSize = 14;
    private System.Threading.Timer? timer;
    private string apiProvider = "";
    private string modelName = "";
    private string lastContext = "";
    private List<string> checkedFolders = new List<string>();
    private DiRAG.Pages.Components.ConfirmDialog confirmDialog = null!;
    private bool clearChatPending = false;
    private bool shouldScrollToBottom = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (shouldScrollToBottom)
        {
            shouldScrollToBottom = false;
            await ScrollToBottomAsync();
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    protected override async Task OnInitializedAsync()
    {
        fontSize = DiRAG.Properties.Settings.Default.Chat_FontSize;

        // Load API Provider and Model information
        var chatMethod = DiRAG.Properties.Settings.Default.ChatMethod;
        if (chatMethod == "GGUF")
        {
            apiProvider = "Local GGUF";
            modelName = DiRAG.Properties.Settings.Default.ChatGGUFModel;
        }
        else
        {
            apiProvider = DiRAG.Properties.Settings.Default.API_Provider;
            if (apiProvider == "Claude Code")
            {
                modelName = DiRAG.Properties.Settings.Default.ClaudeCode_Model;
            }
            else
            {
                modelName = DiRAG.Properties.Settings.Default.OpenAI_Model;
            }
        }

        // Get initial checked folders
        checkedFolders = MainForm.GetCheckedFolders();

        // Subscribe to theme changes
        MainForm.ThemeChanged += OnThemeChanged;

        // Apply initial theme
        await ApplyThemeAsync(MainForm.GetThemeMode());

        // Display selected directories on startup
        if (checkedFolders.Count > 0)
        {
            var foldersList = string.Join("\n", checkedFolders.Select((f, i) => $"{i + 1}. {f}"));
            chatHistory.Add(new ChatMessage
            {
                Text = $"[{Localization.GetString("SelectedDirectories")}]\n{foldersList}",
                IsUser = true,
                Type = MessageType.Info
            });
        }
        else
        {
            chatHistory.Add(new ChatMessage
            {
                Text = $"[{Localization.GetString("SelectedDirectories")}]\n{Localization.GetString("NoDirectoriesSelected")}",
                IsUser = true,
                Type = MessageType.Info
            });
        }

        // Set flag to scroll after initial render
        shouldScrollToBottom = true;

        // Subscribe to culture change events
        if (Localization != null)
        {
            Localization.CultureChanged += OnCultureChanged;
        }

        timer = new System.Threading.Timer(async _ =>
        {
            var newFontSize = DiRAG.Properties.Settings.Default.Chat_FontSize;
            if (fontSize != newFontSize)
            {
                fontSize = newFontSize;
                await InvokeAsync(StateHasChanged);
            }

            // Update API Provider and Model if changed
            var chatMethod = DiRAG.Properties.Settings.Default.ChatMethod;
            string newApiProvider;
            string newModelName;

            if (chatMethod == "GGUF")
            {
                newApiProvider = "Local GGUF";
                newModelName = DiRAG.Properties.Settings.Default.ChatGGUFModel;
            }
            else
            {
                newApiProvider = DiRAG.Properties.Settings.Default.API_Provider;
                newModelName = newApiProvider == "Claude Code"
                    ? DiRAG.Properties.Settings.Default.ClaudeCode_Model
                    : DiRAG.Properties.Settings.Default.OpenAI_Model;
            }

            // Update checked folders
            var newCheckedFolders = MainForm.GetCheckedFolders();
            bool foldersChanged = !checkedFolders.SequenceEqual(newCheckedFolders);

            if (apiProvider != newApiProvider || modelName != newModelName || foldersChanged)
            {
                apiProvider = newApiProvider;
                modelName = newModelName;
                checkedFolders = newCheckedFolders;

                // Auto-display selected directories when folders change
                if (foldersChanged)
                {
                    await InvokeAsync(async () =>
                    {
                        if (newCheckedFolders.Count > 0)
                        {
                            var foldersList = string.Join("\n", newCheckedFolders.Select((f, i) => $"{i + 1}. {f}"));
                            chatHistory.Add(new ChatMessage
                            {
                                Text = $"[{Localization.GetString("SelectedDirectories")}]\n{foldersList}",
                                IsUser = true,
                                Type = MessageType.Info
                            });
                        }
                        else
                        {
                            chatHistory.Add(new ChatMessage
                            {
                                Text = $"[{Localization.GetString("SelectedDirectories")}]\n{Localization.GetString("NoDirectoriesSelected")}",
                                IsUser = true,
                                Type = MessageType.Info
                            });
                        }
                        shouldScrollToBottom = true;
                        StateHasChanged();
                    });
                }
                else
                {
                    await InvokeAsync(StateHasChanged);
                }
            }
        }, null, TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(100));
    }

    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(currentMessage))
            return;

        string userMessage = currentMessage;
        currentMessage = string.Empty;

        chatHistory.Add(new ChatMessage { Text = userMessage, IsUser = true });

        isWaitingForResponse = true;
        shouldScrollToBottom = true;
        StateHasChanged();

        try
        {
            var response = await ChatService.SendMessageAsync(userMessage);

            // Get the last context used (always check, as it's a static property)
            lastContext = DiRAG.Services.RagEnabledChatService.LastContext;

            isWaitingForResponse = false;

            // Determine message type based on response content
            var messageType = MessageType.Normal;
            var errorPrefix = $"[{Localization.GetString("Error")}]";
            var vectorizationErrorPrefix = $"[{Localization.GetString("VectorizationError")}";
            if (response.StartsWith(vectorizationErrorPrefix) || response.StartsWith(errorPrefix) ||
                response.StartsWith("[Vectorization Error") || response.StartsWith("[Error]"))
            {
                messageType = MessageType.Error;
            }

            chatHistory.Add(new ChatMessage { Text = response, IsUser = false, Type = messageType });
        }
        catch (Exception ex)
        {
            isWaitingForResponse = false;

            // Create error message with exception details
            var errorMessage = $"[{Localization.GetString("Error")}]\n\n{Localization.GetString("FailedToSendMessage")}\n\n" +
                             $"{Localization.GetString("ErrorType")}: {ex.GetType().Name}\n" +
                             $"{Localization.GetString("ErrorMessage")}: {ex.Message}\n\n" +
                             $"{Localization.GetString("SuggestedActions")}:\n" +
                             $"• {Localization.GetString("CheckAPIConfiguration")}\n" +
                             $"• {Localization.GetString("VerifyInternetConnection")}\n" +
                             $"• {Localization.GetString("CheckServiceAvailability")}\n" +
                             $"• {Localization.GetString("ReviewErrorDetails")}";

            // Add error message to chat history
            chatHistory.Add(new ChatMessage {
                Text = errorMessage,
                IsUser = true,
                Type = MessageType.Error
            });
        }

        shouldScrollToBottom = true;
        StateHasChanged();
    }

    public void Dispose()
    {
        timer?.Dispose();

        // Unsubscribe from culture change events
        if (Localization != null)
        {
            Localization.CultureChanged -= OnCultureChanged;
        }

        // Unsubscribe from theme change events
        if (MainForm != null)
        {
            MainForm.ThemeChanged -= OnThemeChanged;
        }
    }

    private async void OnThemeChanged(object? sender, string themeMode)
    {
        await ApplyThemeAsync(themeMode);
        await InvokeAsync(StateHasChanged);
    }

    private async Task ApplyThemeAsync(string themeMode)
    {
        try
        {
            // Remove all theme classes first
            await JSRuntime.InvokeVoidAsync("eval", "document.body.classList.remove('dark-mode', 'dark-mode-indigo')");

            // Apply the appropriate theme class
            if (themeMode == "dark-indigo")
            {
                await JSRuntime.InvokeVoidAsync("eval", "document.body.classList.add('dark-mode-indigo')");
            }
            else if (themeMode == "dark")
            {
                await JSRuntime.InvokeVoidAsync("eval", "document.body.classList.add('dark-mode')");
            }
            // For "light" mode, no class is added (already removed above)
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error applying theme: {ex.Message}");
        }
    }

    private void OnCultureChanged(object? sender, System.Globalization.CultureInfo e)
    {
        // Refresh UI when culture changes
        InvokeAsync(StateHasChanged);
    }

    private enum MessageType
    {
        Normal,
        Error,
        Info
    }

    private class ChatMessage
    {
        public string Text { get; set; } = string.Empty;
        public bool IsUser { get; set; }
        public MessageType Type { get; set; } = MessageType.Normal;
    }

    private string GetMessageCssClass(ChatMessage message)
    {
        if (message.Type == MessageType.Error)
            return "border border-danger bg-danger-subtle text-danger";
        if (message.Type == MessageType.Info)
            return message.IsUser ? "border border-info bg-info-subtle text-dark" : "border border-info bg-info-subtle text-dark";

        return message.IsUser ? "bg-primary" : "bg-secondary";
    }

    private string GetMessageStyle(ChatMessage message)
    {
        if (message.Type == MessageType.Error)
            return "border-width: 2px !important;";
        if (message.Type == MessageType.Info)
            return "border-width: 1px !important;";
        return "";
    }

    private async Task ScrollToBottomAsync()
    {
        await JSRuntime.InvokeVoidAsync("chatFunctions.scrollToBottom", "chatContainer");
    }

    private async void ShowContextDialog()
    {
        if (!string.IsNullOrEmpty(lastContext))
        {
            // For now, just add the context to chat history as a system message
            chatHistory.Add(new ChatMessage {
                Text = $"[{Localization.GetString("LastContextUsed")}]\n" + lastContext,
                IsUser = true,
                Type = MessageType.Info
            });
            StateHasChanged();
        }
        else
        {
            chatHistory.Add(new ChatMessage {
                Text = Localization.GetString("NoContextUsedYet"),
                IsUser = true,
                Type = MessageType.Info
            });
            StateHasChanged();
        }
        shouldScrollToBottom = true;
        await InvokeAsync(StateHasChanged);
    }

    private async void ShowSelectedDirectories()
    {
        var folders = MainForm.GetCheckedFolders();

        if (folders.Count > 0)
        {
            var foldersList = string.Join("\n", folders.Select((f, i) => $"{i + 1}. {f}"));
            chatHistory.Add(new ChatMessage {
                Text = $"[{Localization.GetString("SelectedDirectories")}]\n{foldersList}",
                IsUser = true,
                Type = MessageType.Info
            });
        }
        else
        {
            chatHistory.Add(new ChatMessage {
                Text = $"[{Localization.GetString("SelectedDirectories")}]\n{Localization.GetString("NoDirectoriesSelected")}",
                IsUser = true,
                Type = MessageType.Info
            });
        }
        shouldScrollToBottom = true;
        StateHasChanged();
    }

    private async Task ClearChat()
    {
        // If there's no chat history, nothing to clear
        if (chatHistory.Count == 0)
            return;

        // Set flag to indicate clear chat is pending
        clearChatPending = true;

        // Show confirmation dialog using custom component
        await confirmDialog.ShowAsync(
            Localization.GetString("ClearChatTitle"),
            Localization.GetString("ClearChatConfirmation"),
            Localization.GetString("OK"),
            Localization.GetString("Cancel")
        );
    }

    private void HandleConfirmDialogResult(bool confirmed)
    {
        if (clearChatPending && confirmed)
        {
            // Clear the chat history
            chatHistory.Clear();

            // Reset the current message
            currentMessage = string.Empty;

            // Reset the last context
            lastContext = string.Empty;

            // Reset waiting state
            isWaitingForResponse = false;

            // Update the UI
            StateHasChanged();
        }

        // Reset the pending flag
        clearChatPending = false;
    }

    private void OnFontSizeChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int newSize))
        {
            fontSize = newSize;
            // Save the font size to settings
            DiRAG.Properties.Settings.Default.Chat_FontSize = fontSize;
            DiRAG.Properties.Settings.Default.Save();
            StateHasChanged();
        }
    }
}